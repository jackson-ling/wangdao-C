//                                                结构体
/*
 * 1.定义：把不同类型数据打包在一起，便于访问数据（和py里面的字典类似，有键和值）
 * 2.使用说明：1.先声明类型，在定义变量名(结构体：struct;变量：student 1，student 2)
 *           2.结构体需要放在main函数之前
 *           3.易错：结构体之后的大括号需要有分号（区别于定义函数）
 *           4.主函数中的变量名不能和结构体类型名称一样，但是可以和结构体中的成员同名（局部变量的引用）
 * 3.示例：
 *    struct student
 *    {
 *       int num;
 *       char name[20];
 *       int age;
 *    };
 *    结构体的数据和结构体中的数据类型是一一对应的
 *    初始化：struct student s={1001，“lele”，'M'，20，85.4，“Shenzhen”}（用一个大括号。数据类型一一对应）
 *    当有多个数据录入时：需要注意 %c（不会忽略任何字符），前面要有一个空格
 *
 *  结构体的输出只能一个个访问（访问方式：结构体变量名称.结构体内的数据类型）
 *  printf("%d",s.num)
 *
 *
 *  结构体数组的使用
 *  定义：struct student sarr[3]
 *
 *  for循环录入三次，数据访问方式同上，这里只是换成了数组
 *  for(i=0,i<3,i++)
 *  {
 *     例：&sarr[i].num
 *  }
 *
 *                                                 结构体对齐
 *                                            （考研：问结构体的大小）
 *
 *  1.核心一句话：结构体的大小必须是其最大成员的整数倍（最大成员不包含数组）
 *  2.为什么要对齐？------为了CPU更高效的读取内存上的数据
 *
 *  补充:定义了一个变量，就算不赋值也会占用内存空间
 *
 *  3.数据类型的字节大小
 *  整型：int 4
 *       shot 2
 *  浮点：float 4
 *       double 8
 *  字符：char 1（注意结束符也要占用一个字节）
 *
 *  重点：结构体对齐的计算方法
 *
 *  struct student
 *  {
 *      int num;
 *      char name[20];
 *      char sex;
 *      char addr[30];
 *  };
 *
 *分析：
 *    1.数组不算如最大成员，这里的最大成员（int）是4，向他对其-------4
 *    2.20可以被4除尽，已经对齐-----20
 *    3.char sex是一个字符，需要对齐-----1 +3
 *    4.char addr[30] 除4不可以整除，加2-----30 +2
 *
 * 加和知道结构体的大小是60
 *
 *
 * 例二：
 *   struct student_typel
 *   {
 *      double score;
 *      short age;
 *   }
 *   最大成员是8，short向最大成员对齐，结构体的大小就是16
 *
 *    重点：如果两个存储之和是小于最大长度8，，那么他们就结合在一起
 *  struct student_type2
 *  {
 *      double score;
 *      char height;
 *      short age;
 *  }
 *
 *    最大成员是8，char 和 short 加和小于8，这两个合并在一起占用四个字节，向八对齐
 *    所以这个结构体的大小就是16
 *
 *
 *
 *  struct student_type3:
 *  {
 *      int height;
 *      char sex;
 *      short age;
 *  }
 *
 *  最大成员是4，char 和 short 加起来小于4，合并在一起占用四个字节，向4对齐
 *  所以这个结构体的大小就是8
 *
 *
 *
 *                                               结构体指针
 *
 *  注意：.（选择运算符）的优先级高于 *（取值）----  *p  加括号的原因
 *  -----取值  （*p）.num
 *
 *  平常使用结构体指针取值的时候--禁止--使用上面的示例（业界的规范）
 *  统一使用（p->num）(成员选择运算符)
 *
 *  定义：存储的是该变量的其实地址，设置一个结构体指针，指向一个结构体变量，运用指针快速的访问结构体内的每个成员
 *
 *  结构体指针的偏移：和数组指针的偏移类似，+1指针偏移，指向结构体数组的第二个结构体，
 *
 *  malloc申请空间的使用---用一个成员选择运算符给他赋值
 *  p=(struct student*)malloc(sizeof(struct struct student))
 *  p->num=100;
 *  p->sex='M';
 *  strcpy(p->name,"longge");----注意字符串的录入要用strcpy，注意要双引号
 *
 *
 *                                         typedef使用(起别名，简化代码)
 *    作用：统一改变某个--特定数据--的类型，比较方便
 *
 *    1.例子
 *    typedef struct student
 *    {
 *          int num;
 *          char name[20];
 *          cha sex;
 *    }stu,*pstu;
 *
 *   说明：1.stu--表示结构体struct student，可以直接简写
 *        2.*pstu是规定的，当然也可以写成（stu *p），等价于struct student *p---是一个结构体指针
 *
 *    stu *p=&s 等价于 pstu p=&s
 *
 *    2.用于数据类型的改变---typedef int a(通过改变int来改变a的数据类型)
 *
 *                                        C++引用（降低学习数据结构的难度）
 *  注意：这里需要创建C++源文件，但是仍可以支持c语言的头文件---#include<stdio.h>，用c语言的语法写就可以
 *
 *  C++特有的而C语言没有的：定义函数的时候形参的变化（int &b）---c语言不支持
 *
 *  解析（重要）：这里的  &  在C++里面是引用，而不是取地址
 *
 *  实例：让空指针指向某一个地址
 *  void modify_num(int *&p,int *q)---注意：&一定要写在*的前面，表示引用（引用一定要和变量名紧邻）
 *  {              备注：在c语言中，&p等价于*p，即**p（二级指针）---很难理解，考研初试用不到，不用管
 *      p=q；
 *  }
 *
 *   自己对二级指针的小理解（不知道对不对）
 *   首先，之前的指针存放的是一个变量的地址（*p=&a），这个地址里面放了a的值，就是两层关系
 *   这里的*p里面直接存放了一个值，加上又是用指针定义的，可以理解成把NULL这个值放在这个指针里面（指针里面又存了地址）
 *   那需要取出这个值就需要用一个  *  （取值运算符）把值取出来，就是二级指针
 *   ----当然而也可用c++的语法，用c语言理解转换表达式就是二级指针（见上方）
 *
 *
 *
 *  int main()
 *  {
 *     int *p=NULL;---表示一个空指针，NULL=0，不指向任何地方，操作系统规定：0这个地址不可以被访问
 *                   （无法执行的时候退除代码不为0，发出警报）
 *     int a=10;
 *     int *q;
 *     q=&a;
 *     modify_num(p，q);---把a的值传进去，通过引用来改变a的值
 *  }
 *
 *                                                布尔类型
 *  需要包含头文件   #include<stdbool.h>
 *  bool a=true(值为1)
 *  bool b=false(值为0)
 *
*/
#include<stdio.h>
#include<stdbool.h>
int main()
{
    bool a=true;
    bool b=false;
    printf("%d %d",a,b);
}