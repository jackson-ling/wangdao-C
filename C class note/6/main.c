//                                          一.  指针（间接访问）
//（pointer）

/*直接访问的定义：系统给变量分配一个内存空间，存放变量的值（16进制），这个内存空间的位置就是地址
 * ----即通  按变量地址存取变量值  就是  直接访问
 *
 * 每个字节对应一个编号（编值）---这就是--地址
 *
 * 对于某个变量的地址指的是----  起始  地址
 *
 * 关于指针所占字节大小
 * 64位程序---寻址范围是8个字节
 * 32位程序（考研和vs）---寻址范围4个字节
 *
 * 指针---*（是取值），&---是取地址
 *
 *       对于指针的理解
 * 指针变量，存取的是地址，*p---表示取p的地址，然而p里面存的地址就是变量i的地址，变量i的地址又对应i的值
 * ----也就是说  *p  是取p存放的地址对应的变量值（*p=i）
 *
 *                         指针使用规范
 *  1. * 需要紧靠变量
 *
 *  2.  区别二者
 *         char *a，*b，*c
 *         char *a，b，c
 *
 *  3.定义指针变量  必须  指定其类型，同时必须存储对应类型变量的地址
 *  错误：int i;
 *       float *p=&i;
 *
 *  4.指针的变量名
 *  float *p
 *  p是指针变量名，而不是*p
 *
 *  5.无意义的写法(*&i=i,不会这么写)
 *
 *  6.指针实现-----间接访问
 *  int i=5;
 *  int *p=&i;
 *  printf("%d",*p);
 *
 *  如何数地址？
 *  例如定义了一个整型变量（4个字节）
 *  int i=10
 *  地址----0x000000000061fe1c
 *                                                i
 *  00 00 00 00    00 00 00 00    00 00 00 00    0a 00 00 00
 *  10 11 12 13    14 15 16 17    18 19 1a 1b    1c 1d 1e 1f
 *
 *理解：地址是一个编号（编值），变量存储在一个地址中，而变量值存储在变量地址中的一个变量空间里面，
 *     -----因此通过数地址来确定具体存储的值是多少（或者说变量值对应的变量空间位置）
 *
 *
 *                                    二.  指针的使用场景（传递和偏移）
 *  注意：C语言中的函数是--值传递--实参值--传递给--形参
 *
 *  1.传递
 *  void change(int j)
 *  {
 *      j=5;
 *  }
 *  int main()
 *  {
 *      int i=10;
 *      change(i);
 *      printf("%d",i);
 *  }
 *
 *  过程分析
 *         i=10
 *         j=i
 *         j=5
 * 浅层解释：i的值并不会改变，因为是值传递----i=10赋值给了j，j=5相当于改变j的值（可以理解为重新赋值），但是对i的值完全没有影响
 *
 * 深层解释：通过调试查看i，j地址的变化，发现地址i存值没有发生变化(内存没有发生变化)，改变的是j
 *
 * 本质：程序的执行过程其实是内存的变化过程，需要关注栈空间的变化
 *      栈空间的特点：函数执行完成后，为这个函数开辟的栈空间就会消失（可以运行多个子函数的原因）
 *      1.每当一个函数运行时，就会开辟一个栈空间
 *      2.change函数运行时，系统为change函数分配新的函数栈空间（j是int型，分配4个字节大小的空间）
 *      3.在栈空间修改j的值（j=5），执行完成栈空间消失
 *      4.重点：栈空间消失后j的值不存在，i就不会改变
 * -----j对i没有任何影响
 *
 * 直接访问i就可以对变量进行修改
 *  void change(int *j)
 *  {
 *      *j=5;
 *  }
 *  int main()
 *  {
 *      int i=10;
 *      change（&i）;
 *      printf("%d",i);
 *  }
 *
 *
 *  2.偏移（加向右偏移，减向左偏移）
 *  数组中的应用
 *  *(p+i)=a[i]
 *  注意：数组名本身就代表它的---起始--地址，不需要对数组取地址
 *  规定：偏移的长度是基本类型长度（这里i是int类型，占4个字节，在地址的偏移上就会加4）
 *  a[0]=1(等价于*p)，a[1]=2(等价于（*（p+1）)、
 *  a[0]地址：61fdf0
 *  a[1]地址：61fdf4
 *  int main()
 *  {
 *      int i;
 *      int a[5]={1,2,3,4,5};
 *      int *p;
 *      p=a;
 *      printf("%d",*p);//取的是--起始--地址，这里就是取的第一个值
 *      for(i=0;1<5;i++)
 *      {
 *          printf("%d",*（p+i）);//取的是起始地址，这里就是取的第一个值，之后依次通过取不同变量的地址实现--正序输出
 *      }
 *      实现逆序输出
 *      p=&a[5];//初始化p，取最后一个数的地址
 *      for(i=0;i<5;i++)
 *      {
 *          printf("%d",*(p-i));
 *      }
 *  }
 *
 *
 *                                   三.指针于动态内存申请（实现动态数组长度）
 *  1.栈空间：大小确定;堆空间：大小不确定
 *  2.需要包含头文件---#include<stdlib.h>
 *  3.代码实现
 *  int main()
 *  {
 *     int size;
 *     scanf("%d",size);
 *     char *p;//数组明本身就是一个地址，弱化为指针，数组长度用动态内存申请实现
 *     p=(char *)malloc(size);
 *     strcpy(p,"hello");
 *     puts(p);
 *     free(p);
 *     return 0;
 *  }
 *  解析：
 *      1.malloc是向内存申请空间（堆空间），申请的空间不能超过内存大小，堆空间在栈空间下面，堆空间不会消失
 *      2.malloc返回的是无指针类型（void *）---无指针类型不可以偏移，因此要强转成（char *）才可实现偏移
 *      3.特别注意；使用完之后堆空间最后要free还给操作系统，强调---free的空间不可以发生任何偏移，只能是最初malloc返回的地址
 *                否则会报错，退出码不为0
 *      4.存放字符时注意结束符号，当然用strcpy直接复制更方便
 *      5.gets，puts的对象都是指针类型数据
 *
 *   4.堆空间：heap
 *     栈空间：stack
 *     栈空间不可以实现动态，但是堆空间可以
 *
 *   5.堆空间和栈空间的差异
 *   #include<stdio.h>
 *   #include<string.h>
 *   #include<stdlib.h>
 *   //
 *   char*print_stack()
 *   {
 *      char c[17]="I am print_stack";
 *      puts(c);
 *      return c;
 *   }
 *
 *   char* print_malloc()
 *   {
 *      char*p;
 *      p=(char*)malloc(20)
 *      strcpy(p,"I am print_malloc");
 *      puts(p);
 *      return p;
 *   }
 *
 *   int main()
 *   {
 *      char*p;
 *      p=print_stack;//数据存在栈空间
 *      printf("p=%s\n",p);
 *      p=print_malloc();//数据存在堆空间
 *      puts(p);
 *      return 0;
 *   }
 *
 *   分析：
 *   p=print_stack;//数据存在栈空间-----结果出现乱码
 *   原因：在print_stack调用完之后，子函数的栈空间消失，那数据不存在，之后执行puts函数，栈空间覆盖，就会出现乱码
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
*/