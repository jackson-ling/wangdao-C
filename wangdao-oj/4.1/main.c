#include <stdio.h>
//判断对称数(回文数)
//利用循环判断
int main()
{
    int a;//定义输入的数
    int backup_a;//备份
    int b;//定义一个新变量作为逆置数，最后判断  backup_a  与  b   的值是否相等（思路）
    b=0;//初始化为0
    scanf("%d",&a);//易错（逻辑问题）：先输入了a的值才可以去备份，不要反过来，否则结果错误
    backup_a=a;//先备份a的值


    //下面是如何把一个数的每一位单独取出的操作，相当于py对列表的遍历操作（  倒叙  单独输出）
//    while(a)
//    {
//       printf("%d\n",a%10);
//       //由于定义了是整型数，每一次%10把最后一位数去除之后/10相当于把最后一位数去掉生成一个新的数，
//       // 这个数的最后一位就是原来数的倒数第二位，因此又可以取出倒数第二位数
//       a/=10;
//    }



//    举例：如何把23变成32
//    第一步：先取出每一位数字
//    int a;
//    scanf("%d",&a);
//    int b=0;
//    while(a)
//    {
//        //第一步：先去取数
////        printf("%d",a%10);
////        a/=10;
//        //取出的结果是  3  2；
//
////        怎么变成32？
////    第一次取模的结果是3，第二次取模的结果是2---那么只要第一次的取模结果*10+第二次的取模结果就行
//
//        //第二步：尝试逆序打印
//        b=b*10+a%10;//注意：左操作数  和  右操作数  的值每一次循环之后都在改变
//        a/=10;
//
//        //运行过程
//       /* 1.先取模，最后一位是2
//          2.初始化b的值（b就是逆序输出的值），第一次循环b为0，b=3
//          3.第一次循环结束，第二次取模，值是2
//          4.第一次b的值是3，先乘10变成30+第二次取模的值2=32
//       */
//
//
//
//
//
//    }
//    printf("%d",b);







    while(a)//循环条件写  “1”，表示表达式一直为真----执行  死循环
    {
        b=b*10+a%10;
        a/=10;
    }
    if(b==backup_a)
    {
        printf("yes\n");
    }
    else
    {
        printf("no\n");
    }
      return 0;

}

//第一遍自己做的，方法，但只适用于有限低位数
// 没有运用到循环

//int main() {
//    int i;
//    int a,b,c,d,e;
//    int a1,b1,c1,d1,e1;
//
//    scanf("%d",&i);
//    //倒叙遍历一遍
//    a=i%10;//第五位
//    b=(i/10)%10;//第四位
//    c=(i/100)%10;//第三位
//    d=(i/1000)%10;//第二位
//    e=i/10000;//第一位
//    //正序遍历一遍
//    a1=i/10000;//第一位
//    b1=(i/1000)%10;//第二位
//    c1=(i/100)%10;//第三位
//    d1=(i/10)%10;//第四位
//    e1=i%10;//第五位
//
//    if(a==a1,b==b1,c==c1,d==d1,e==e1)
//    {
//        printf("yes\n");
//    }
//    else
//    {
//        printf("no");
//    }
//
//
//
//
//    return 0;
//}
