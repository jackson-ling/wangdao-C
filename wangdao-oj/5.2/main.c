//字符串逆转，并采用strcmp比较大小

#include<stdio.h>
#include<string.h>//注意：应用str字符串系列操作函数需要声明函数库
int main()
{
     char a[10];
     char b[10]={0};//初始化是为了保证有结束符，否则可能出现乱码（地址中会随机存放值）
     int len,result;
     //注意代码逻辑：先录入再统计长度

     //错误：先统计长度再录入
     //分析：此时  字符串数组b  长度为一，在数组中生成一个随机的数16，len长度错了就会导致会面乱码（随机地址）

     gets(a);

     //注意:再vs里面不支持gets（），用fgets（）代替

     //格式： fgets（数组名，sizeof（数组名），stdin）


     //注意养成习惯：录入字符串的时候用gets（）函数，不要用scanf，如果遇到有空格的字符串就无法全部录入
     //scanf("%s",&a[i]);

     len=strlen(a);

     /*不会的点
           -----> 1. 如何逆转字符串？---for循环遍历
           -----> 2. 如何把逆序遍历的字符赋给字符窜数组b？
           通过画图理解发现：只要把顺序中的第一个字符给到逆序的最后一个字符就可以实现逆序输出
     */


     //逆序输出的一些idea：
/*     1.先把a复制到b中，用索引逆向输出
       2.先逆向遍历输出a再把结果放到b里面
       3.利用如下方法，输出a的第一个即对应b的最后一个
*/
     //第一种写法（初始化了b）
     int i,j;
     for(i=0,j=len-1;j>0;i++,j--)//注意下标值比数组长度小一
     {
         b[j]=a[i];
     }


     //第二种写法
    // 从a的末尾开始，逆序复制到b
/*    for (int i = len - 1; i >= 0; i--)
    {
        b[len - 1 - i] = a[i];
    }
    b[len] = '\0'; // 在b的末尾添加空字符，确保它是一个正确的字符串（没有初始化b）
*/

        //测试：打印数组要用循环遍历
    /*    for(i=0;i<10;i++)
        {
            printf("%c",b[i]);
        }
    */


    //易错：
    //要对b进行初始化（char b[10]={0}），初始化是为了保证   字符窜数组b   有结束符，否则可能出现乱码（地址中会随机存放值）

    //问题点：当循环条件加上   j>0   时输出结果就错了---lleh；为什么？（即只用一个边界控制）
/*     解释：
 *        为什么原来的代码是正确的？
 *        1.对于原先的条件理解：首先这个循环是两个变量 i，j 同时在遍历，只需要一个边界控制退出循环即可，
 *          当一个边界满足时，循环结束，那么另一个变量不再遍历
 *        举例：当i遍历到最后一个数（i遍历的是a的字符串（正序输出））的时候，满足边界，循环推出，j不再自减
 *
 *        2.为什么加上边界 j>0 是错误的？(其实加上  j>=0  才是正确的（注意取等），也不会影响结果，边界取一个就可以)
 *        在循环中加入条件 j > 0，那么当 j 递减到 0 时，循环就会停止(因为不再满足 j > 0 的条件)
 *        这会导致数组 b 的第一个元素（索引为 0 的位置）没有被赋值
 *        因为它需要 j 等于 0 时才进行赋值
 *        因此，逆序复制的过程是不完整的，数组 b 的第一个元素将保持未初始化的状态。
*/


/*     不等价于如下：
     for(i=len-1;i>=0;i--)
     {
         for(j=0;j<len-1;j++)
         {
             b[j]=a[i];
         }
     }
    测试：
     puts(b);
*/

/*
 * 解释：主要问题是二者的逻辑不同
 *  1.理解循环嵌套的逻辑，先固定外层循环，在访问内层循环，直到内层循环结束才进行外层循环的下一次访问
 *  2.正确的写法是表示----i,j同时在遍历（需要同时遍历的情况只用一个循环，并且把条件写在一起）

*/


     //如果需要用  嵌套循环  实现逆序输出，如何编写代码？
/*    #include<stdio.h>
    #include<string.h>
        int main()
        {
            char a[100], b[100];
            scanf("%s",a);
            int len = strlen(a);
            for (int i = 0; i < len; i++)
            {
                for (int j = 0; j < 1; j++)
                    //循环一次---每遍历b的一个值就录入一次a逆序的值，即遍历b，把逆序的a一个个正序的放到b里面，
                {
                    b[i] = a[len - 1 - i];//由于是互补的，总和不变（起始：把a的最后一个给b的第一个）
                }
                   b[len] = '\0'; // 在b的末尾添加空字符，确保它是一个正确的字符串（没有初始化b）
            }
            for (int i = 0; i < len; i++)
            {
                printf("%c",b[i]);
            }
            return 0;
        }
*/

    result=strcmp(a,b);
    if(result==0)
    {
        printf("%d\n",0);//注意换行，优化输出格式
    }
    else if(result>0)
    {
        printf("%d\n",1);//注意换行，优化输出格式
    }
    else if(result<0)
    {
        printf("%d\n",-1);//注意换行，优化输出格式
    }

     return 0;

}